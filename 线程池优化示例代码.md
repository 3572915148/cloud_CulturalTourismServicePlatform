# çº¿ç¨‹æ± ä¼˜åŒ–ç¤ºä¾‹ä»£ç 

æœ¬æ–‡æ¡£æä¾›äº†åœ¨é¡¹ç›®ä¸­ä½¿ç”¨çº¿ç¨‹æ± è¿›è¡Œæ€§èƒ½ä¼˜åŒ–çš„å…·ä½“ä»£ç ç¤ºä¾‹ã€‚

## ä¸€ã€StockSyncScheduler ä¼˜åŒ–ç¤ºä¾‹

### ä¼˜åŒ–å‰ï¼ˆä¸²è¡Œæ‰§è¡Œï¼‰
```java
@Scheduled(cron = "0 */5 * * * ?")
public void syncStockToDatabase() {
    // ... æŸ¥è¯¢æ‰€æœ‰å•†å“ ...
    
    for (Product product : products) {
        try {
            stockService.forceSyncStockToDB(product.getId());
            successCount++;
        } catch (Exception e) {
            log.error("åŒæ­¥å¤±è´¥: productId={}", product.getId(), e);
            failCount++;
        }
    }
}
```

### ä¼˜åŒ–åï¼ˆå¹¶è¡Œæ‰§è¡Œï¼‰
```java
@Autowired
@Qualifier("stockSyncExecutor")
private ThreadPoolTaskExecutor stockSyncExecutor;

@Scheduled(cron = "0 */5 * * * ?")
public void syncStockToDatabase() {
    StringRedisTemplate redisTemplate = redisConfig.getStringRedisTemplate();
    if (redisTemplate == null) {
        log.debug("Redisæœªé…ç½®ï¼Œè·³è¿‡åº“å­˜åŒæ­¥");
        return;
    }
    
    try {
        log.info("ğŸ”„ å¼€å§‹å®šæ—¶åŒæ­¥åº“å­˜åˆ°æ•°æ®åº“...");
        
        // æŸ¥è¯¢æ‰€æœ‰ä¸Šæ¶çš„å•†å“
        List<Product> products = productMapper.selectList(
            new LambdaQueryWrapper<Product>()
                .eq(Product::getStatus, 1)
        );
        
        // ä½¿ç”¨çº¿ç¨‹æ± å¹¶è¡Œå¤„ç†
        List<CompletableFuture<SyncResult>> futures = products.stream()
            .map(product -> CompletableFuture.supplyAsync(() -> {
                try {
                    stockService.forceSyncStockToDB(product.getId());
                    return new SyncResult(product.getId(), true, null);
                } catch (Exception e) {
                    log.error("âŒ åŒæ­¥å•†å“åº“å­˜å¤±è´¥: productId={}, error={}", 
                        product.getId(), e.getMessage(), e);
                    return new SyncResult(product.getId(), false, e.getMessage());
                }
            }, stockSyncExecutor))
            .collect(Collectors.toList());
        
        // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆå¹¶ç»Ÿè®¡ç»“æœ
        List<SyncResult> results = futures.stream()
            .map(CompletableFuture::join)
            .collect(Collectors.toList());
        
        int successCount = (int) results.stream().filter(SyncResult::isSuccess).count();
        int failCount = results.size() - successCount;
        
        log.info("âœ… åº“å­˜åŒæ­¥å®Œæˆ: æˆåŠŸ={}, å¤±è´¥={}, æ€»è®¡={}", 
            successCount, failCount, products.size());
    } catch (Exception e) {
        log.error("âŒ å®šæ—¶åŒæ­¥åº“å­˜ä»»åŠ¡æ‰§è¡Œå¤±è´¥: error={}", e.getMessage(), e);
    }
}

// è¾…åŠ©ç±»
private static class SyncResult {
    private final Long productId;
    private final boolean success;
    private final String error;
    
    public SyncResult(Long productId, boolean success, String error) {
        this.productId = productId;
        this.success = success;
        this.error = error;
    }
    
    public boolean isSuccess() {
        return success;
    }
}
```

---

## äºŒã€StockService ä¼˜åŒ–ç¤ºä¾‹

### ä¼˜åŒ–å‰ï¼ˆä½¿ç”¨ new Threadï¼‰
```java
private void syncStockToDBAsync(Long productId) {
    new Thread(() -> {
        try {
            // åŒæ­¥é€»è¾‘
        } catch (Exception e) {
            log.error("åŒæ­¥å¤±è´¥", e);
        }
    }).start();
}
```

### ä¼˜åŒ–åï¼ˆä½¿ç”¨çº¿ç¨‹æ± ï¼‰
```java
@Autowired
@Qualifier("stockAsyncExecutor")
private ThreadPoolTaskExecutor stockAsyncExecutor;

private void syncStockToDBAsync(Long productId) {
    stockAsyncExecutor.execute(() -> {
        try {
            StringRedisTemplate redisTemplate = getRedisTemplate();
            if (redisTemplate == null) {
                return;
            }
            
            String stockKey = STOCK_KEY_PREFIX + productId;
            String stockStr = redisTemplate.opsForValue().get(stockKey);
            
            if (stockStr == null) {
                return;
            }
            
            Integer stock = Integer.parseInt(stockStr);
            
            // ä½¿ç”¨åˆ†å¸ƒå¼é”åŒæ­¥åˆ°æ•°æ®åº“
            redisLockUtil.executeWithLock("stock:sync:" + productId, 3, 10, () -> {
                Product product = productMapper.selectById(productId);
                if (product != null) {
                    product.setStock(stock);
                    productMapper.updateById(product);
                    log.debug("âœ… åº“å­˜å·²åŒæ­¥åˆ°æ•°æ®åº“: productId={}, stock={}", productId, stock);
                }
                return null;
            });
        } catch (Exception e) {
            log.error("âŒ åŒæ­¥åº“å­˜åˆ°æ•°æ®åº“å¤±è´¥: productId={}, error={}", productId, e.getMessage(), e);
        }
    });
}
```

---

## ä¸‰ã€AgentServiceImpl å·¥å…·å¹¶è¡Œæ‰§è¡Œç¤ºä¾‹

### ä¼˜åŒ–å‰ï¼ˆä¸²è¡Œæ‰§è¡Œï¼‰
```java
private List<ToolResult> executeTools(Map<Integer, ToolCallAccumulator> toolCallsMap, 
                                      ConversationContext context, 
                                      SseEmitter emitter) throws Exception {
    List<ToolResult> results = new ArrayList<>();
    
    for (Map.Entry<Integer, ToolCallAccumulator> entry : toolCallsMap.entrySet()) {
        // ä¸²è¡Œæ‰§è¡Œæ¯ä¸ªå·¥å…·
        ToolResult result = executeSingleTool(entry, context, emitter);
        results.add(result);
    }
    
    return results;
}
```

### ä¼˜åŒ–åï¼ˆå¹¶è¡Œæ‰§è¡Œï¼‰
```java
@Autowired
@Qualifier("agentToolExecutor")
private ThreadPoolTaskExecutor agentToolExecutor;

private List<ToolResult> executeTools(Map<Integer, ToolCallAccumulator> toolCallsMap, 
                                      ConversationContext context, 
                                      SseEmitter emitter) throws Exception {
    
    // å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰å·¥å…·
    List<CompletableFuture<ToolResult>> futures = toolCallsMap.entrySet().stream()
        .map(entry -> CompletableFuture.supplyAsync(() -> {
            try {
                return executeSingleTool(entry, context, emitter);
            } catch (Exception e) {
                log.error("å·¥å…·æ‰§è¡Œå¤±è´¥: {}", entry.getKey(), e);
                return ToolResult.error("å·¥å…·æ‰§è¡Œå¤±è´¥: " + e.getMessage(), "TOOL_EXECUTION_ERROR");
            }
        }, agentToolExecutor))
        .collect(Collectors.toList());
    
    // ç­‰å¾…æ‰€æœ‰å·¥å…·æ‰§è¡Œå®Œæˆ
    List<ToolResult> results = futures.stream()
        .map(CompletableFuture::join)
        .collect(Collectors.toList());
    
    return results;
}

private ToolResult executeSingleTool(Map.Entry<Integer, ToolCallAccumulator> entry,
                                     ConversationContext context,
                                     SseEmitter emitter) {
    ToolCallAccumulator accumulator = entry.getValue();
    String toolName = accumulator.functionName;
    String argsStr = accumulator.arguments.toString();
    
    if (toolName == null || argsStr == null || argsStr.isEmpty()) {
        log.warn("âš ï¸ å·¥å…·è°ƒç”¨ä¿¡æ¯ä¸å®Œæ•´: name={}, args={}", toolName, argsStr);
        return ToolResult.error("å·¥å…·è°ƒç”¨ä¿¡æ¯ä¸å®Œæ•´", "INVALID_TOOL_CALL");
    }
    
    log.info("ğŸ”§ AIè¯·æ±‚è°ƒç”¨å·¥å…·: {}, å‚æ•°: {}", toolName, argsStr);
    
    try {
        Map<String, Object> args = JSON.parseObject(argsStr, 
            new TypeReference<Map<String, Object>>() {});
        
        // é€šçŸ¥å‰ç«¯æ­£åœ¨è°ƒç”¨å·¥å…·
        Map<String, Object> toolCallInfo = new HashMap<>();
        toolCallInfo.put("tool", toolName);
        toolCallInfo.put("parameters", args);
        
        emitter.send(SseEmitter.event()
            .name("tool_call")
            .data(JSON.toJSONString(toolCallInfo)));
        
        // æ‰§è¡Œå·¥å…·
        AgentTool tool = toolRegistry.getTool(toolName);
        if (tool != null) {
            ToolResult result = tool.execute(args, context.getUserId());
            
            // é€šçŸ¥å‰ç«¯å·¥å…·æ‰§è¡Œç»“æœ
            if (!"get_product_categories".equals(toolName)) {
                emitter.send(SseEmitter.event()
                    .name("tool_result")
                    .data(JSON.toJSONString(result)));
            }
            
            log.info("âœ… å·¥å…·æ‰§è¡ŒæˆåŠŸ: {}", toolName);
            return result;
        } else {
            log.error("âš ï¸ å·¥å…·ä¸å­˜åœ¨: {}", toolName);
            ToolResult errorResult = ToolResult.error("å·¥å…·ä¸å­˜åœ¨ï¼š" + toolName, "TOOL_NOT_FOUND");
            emitter.send(SseEmitter.event()
                .name("tool_result")
                .data(JSON.toJSONString(errorResult)));
            return errorResult;
        }
    } catch (Exception e) {
        log.error("âŒ å·¥å…·æ‰§è¡Œå¤±è´¥: {}", toolName, e);
        ToolResult errorResult = ToolResult.error("å·¥å…·æ‰§è¡Œå¤±è´¥ï¼š" + e.getMessage(), "TOOL_EXECUTION_ERROR");
        emitter.send(SseEmitter.event()
            .name("tool_result")
            .data(JSON.toJSONString(errorResult)));
        return errorResult;
    }
}
```

---

## å››ã€AiRecommendationServiceImpl æµå¼å¤„ç†ä¼˜åŒ–

### ä¼˜åŒ–å‰ï¼ˆä½¿ç”¨ new Threadï¼‰
```java
Thread streamThread = new Thread(() -> {
    try {
        // æµå¼å¤„ç†é€»è¾‘
    } catch (Exception e) {
        log.error("å¤„ç†å¤±è´¥", e);
    }
});
streamThread.setName("AI-Stream-" + userId);
streamThread.setDaemon(true);
streamThread.start();
```

### ä¼˜åŒ–åï¼ˆä½¿ç”¨çº¿ç¨‹æ± ï¼‰
```java
@Autowired
@Qualifier("aiStreamExecutor")
private ThreadPoolTaskExecutor aiStreamExecutor;

// åœ¨ getRecommendationStream æ–¹æ³•ä¸­
aiStreamExecutor.execute(() -> {
    try {
        log.info("æµå¼æ¨é€çº¿ç¨‹å¼€å§‹æ‰§è¡Œ");
        
        // åŸæœ‰æµå¼å¤„ç†é€»è¾‘
        callDeepSeekStreamAPI(prompt, emitter, fullResponse);
        
        // ... å…¶ä»–å¤„ç†é€»è¾‘ ...
        
        emitter.complete();
        log.info("æµå¼AIæ¨èè¯·æ±‚å¤„ç†å®Œæˆ");
    } catch (Exception e) {
        log.error("æµå¼æ¨é€å¤„ç†å¤±è´¥", e);
        try {
            Map<String, Object> errorData = new HashMap<>();
            errorData.put("type", "error");
            errorData.put("message", "AIæ¨èæœåŠ¡æš‚æ—¶ä¸å¯ç”¨");
            String errorJson = objectMapper.writeValueAsString(errorData);
            emitter.send(SseEmitter.event().data(errorJson));
        } catch (Exception ex) {
            log.error("å‘é€é”™è¯¯æ¶ˆæ¯å¤±è´¥", ex);
        } finally {
            emitter.completeWithError(e);
        }
    }
});
```

---

## äº”ã€SessionConsistencyService æ‰¹é‡æ£€æŸ¥ä¼˜åŒ–

### ä¼˜åŒ–å‰ï¼ˆä¸²è¡Œæ£€æŸ¥ï¼‰
```java
List<Long> missingIds = new ArrayList<>();
for (Long recommendationId : recommendationIds) {
    AiRecommendation recommendation = aiRecommendationMapper.selectById(recommendationId);
    if (recommendation == null) {
        missingIds.add(recommendationId);
    }
}
```

### ä¼˜åŒ–åï¼ˆå¹¶è¡Œæ£€æŸ¥ï¼‰
```java
@Autowired
@Qualifier("consistencyCheckExecutor")
private ThreadPoolTaskExecutor consistencyCheckExecutor;

// åœ¨ checkAndFixConsistency æ–¹æ³•ä¸­
List<CompletableFuture<Boolean>> futures = recommendationIds.stream()
    .map(id -> CompletableFuture.supplyAsync(() -> {
        AiRecommendation recommendation = aiRecommendationMapper.selectById(id);
        return recommendation != null;
    }, consistencyCheckExecutor))
    .collect(Collectors.toList());

// æ”¶é›†ç¼ºå¤±çš„ID
List<Long> missingIds = new ArrayList<>();
for (int i = 0; i < recommendationIds.size(); i++) {
    Boolean exists = futures.get(i).join();
    if (!exists) {
        missingIds.add(recommendationIds.get(i));
    }
}
```

---

## å…­ã€AiRecommendationServiceImpl äº§å“æŸ¥è¯¢ä¼˜åŒ–

### ä¼˜åŒ–å‰ï¼ˆä¸²è¡ŒæŸ¥è¯¢ï¼‰
```java
private List<AiRecommendationVO.RecommendedProductVO> getProductVOs(List<Long> productIds) {
    return productIds.stream().map(id -> {
        Product product = productMapper.selectById(id);
        if (product == null) {
            return null;
        }
        // è½¬æ¢ä¸ºVO
        return convertToVO(product);
    }).filter(Objects::nonNull).collect(Collectors.toList());
}
```

### ä¼˜åŒ–åï¼ˆå¹¶è¡ŒæŸ¥è¯¢ï¼‰
```java
@Autowired
@Qualifier("productQueryExecutor")
private ThreadPoolTaskExecutor productQueryExecutor;

private List<AiRecommendationVO.RecommendedProductVO> getProductVOs(List<Long> productIds) {
    List<CompletableFuture<AiRecommendationVO.RecommendedProductVO>> futures = 
        productIds.stream()
            .map(id -> CompletableFuture.supplyAsync(() -> {
                Product product = productMapper.selectById(id);
                if (product == null) {
                    return null;
                }
                return convertToVO(product);
            }, productQueryExecutor))
            .collect(Collectors.toList());
    
    return futures.stream()
        .map(CompletableFuture::join)
        .filter(Objects::nonNull)
        .collect(Collectors.toList());
}
```

---

## ä¸ƒã€æ³¨æ„äº‹é¡¹

### 1. å¼‚å¸¸å¤„ç†
å¹¶è¡Œæ‰§è¡Œæ—¶ï¼Œç¡®ä¿æ¯ä¸ªä»»åŠ¡éƒ½æœ‰å¼‚å¸¸å¤„ç†ï¼Œé¿å…ä¸€ä¸ªä»»åŠ¡å¤±è´¥å½±å“å…¶ä»–ä»»åŠ¡ã€‚

### 2. äº‹åŠ¡ç®¡ç†
æ³¨æ„å¹¶è¡Œä»»åŠ¡ä¸­çš„äº‹åŠ¡è¾¹ç•Œï¼Œç¡®ä¿æ•°æ®ä¸€è‡´æ€§ã€‚

### 3. èµ„æºé™åˆ¶
æ ¹æ®æ•°æ®åº“è¿æ¥æ± å¤§å°å’ŒæœåŠ¡å™¨èµ„æºè°ƒæ•´çº¿ç¨‹æ± å‚æ•°ã€‚

### 4. ç›‘æ§å’Œæ—¥å¿—
æ·»åŠ çº¿ç¨‹æ± ä½¿ç”¨æƒ…å†µçš„ç›‘æ§å’Œæ—¥å¿—ï¼Œä¾¿äºé—®é¢˜æ’æŸ¥ã€‚

### 5. ä¼˜é›…å…³é—­
ç¡®ä¿åº”ç”¨å…³é—­æ—¶ï¼Œçº¿ç¨‹æ± èƒ½å¤Ÿä¼˜é›…åœ°ç­‰å¾…ä»»åŠ¡å®Œæˆã€‚

---

## å…«ã€æ€§èƒ½æµ‹è¯•å»ºè®®

åœ¨å®æ–½ä¼˜åŒ–åï¼Œå»ºè®®è¿›è¡Œæ€§èƒ½æµ‹è¯•ï¼š

1. **å‹åŠ›æµ‹è¯•**: æ¨¡æ‹Ÿé«˜å¹¶å‘åœºæ™¯ï¼Œè§‚å¯Ÿçº¿ç¨‹æ± ä½¿ç”¨æƒ…å†µ
2. **å“åº”æ—¶é—´**: å¯¹æ¯”ä¼˜åŒ–å‰åçš„å“åº”æ—¶é—´
3. **èµ„æºä½¿ç”¨**: ç›‘æ§CPUã€å†…å­˜ã€æ•°æ®åº“è¿æ¥ç­‰èµ„æºä½¿ç”¨æƒ…å†µ
4. **é”™è¯¯ç‡**: è§‚å¯Ÿä¼˜åŒ–åçš„é”™è¯¯ç‡æ˜¯å¦å¢åŠ 

---

## æ€»ç»“

é€šè¿‡ä½¿ç”¨çº¿ç¨‹æ± ï¼Œå¯ä»¥æ˜¾è‘—æå‡ä»¥ä¸‹åœºæ™¯çš„æ€§èƒ½ï¼š

1. âœ… æ‰¹é‡æ“ä½œï¼ˆåº“å­˜åŒæ­¥ã€æ•°æ®ä¸€è‡´æ€§æ£€æŸ¥ï¼‰
2. âœ… å¼‚æ­¥ä»»åŠ¡ï¼ˆåº“å­˜åŒæ­¥ã€æ–‡ä»¶å¤„ç†ï¼‰
3. âœ… å¹¶è¡ŒæŸ¥è¯¢ï¼ˆäº§å“è¯¦æƒ…æŸ¥è¯¢ï¼‰
4. âœ… å·¥å…·è°ƒç”¨ï¼ˆAI Agentå·¥å…·å¹¶è¡Œæ‰§è¡Œï¼‰

å»ºè®®æŒ‰ç…§ä¼˜å…ˆçº§é€æ­¥å®æ–½ï¼Œå¹¶åœ¨å®æ–½è¿‡ç¨‹ä¸­æŒç»­ç›‘æ§å’Œä¼˜åŒ–ã€‚

